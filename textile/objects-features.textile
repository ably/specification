---
title: Objects Features
section: client-lib-development-guide
index: 65
jump_to:
  Help with:
    - Objects Features Overview#overview
---

h2(#overview). Overview

This document outlines the feature specification for the Objects feature of the Realtime system. It is currently under development and stored separately from the main specification to simplify the initial implementation of the feature in other SDKs. Once completed, it will be moved to the main "features":../features spec.

Objects feature enables clients to store shared data as "objects" on a channel. When an object is updated, changes are automatically propagated to all subscribed clients in realtime, ensuring each client always sees the latest state.

h3(#realtime-objects). RealtimeObjects

* @(RTO1)@ @RealtimeObjects#getRoot@ function:
** @(RTO1a)@ Requires the @OBJECT_SUBSCRIBE@ channel mode to be granted per "RTO2":#RTO2
** @(RTO1b)@ If the channel is in the @DETACHED@ or @FAILED@ state, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 90001
** @(RTO1c)@ Waits for the objects sync sequence to complete and for "RTO5c":#RTO5c to finish
** @(RTO1d)@ Returns the object with id @root@ from the internal @ObjectsPool@ as a @LiveMap@
* @(RTO11)@ @RealtimeObjects#createMap@ function:
** @(RTO11a)@ Expects the following arguments:
*** @(RTO11a1)@ @entries@ @Dict<String, Boolean | Binary | Number | String | JsonArray | JsonObject | LiveCounter | LiveMap>@ (optional) - the initial entries for the new @LiveMap@ object
** @(RTO11b)@ The return type is a @LiveMap@, which is returned once the required I/O has successfully completed
** @(RTO11c)@ Requires the @OBJECT_PUBLISH@ channel mode to be granted per "RTO2":#RTO2
** @(RTO11d)@ If the channel is in the @DETACHED@, @FAILED@ or @SUSPENDED@ state, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 90001
** @(RTO11e)@ If "@echoMessages@":../features#TO3h client option is @false@, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 40000, indicating that @echoMessages@ must be enabled for this operation
** @(RTO11f)@ Creates an @ObjectMessage@ for a @MAP_CREATE@ action in the following way:
*** @(RTO11f1)@ If @entries@ is null or not of type @Dict@, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 40003, indicating that @entries@ must be a @Dict@. Note that @entries@ is an optional argument, and if omitted, this error must not be thrown
*** @(RTO11f2)@ If any of the keys provided in @entries@ are not of type @String@, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 40003, indicating that keys must be @String@
*** @(RTO11f3)@ If any of the values provided in @entries@ are not of an expected type, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 40013, indicating that such data type is unsupported
*** @(RTO11f4)@ Create a partial @ObjectOperation@ with the initial value for the new @LiveMap@:
**** @(RTO11f4a)@ Set @ObjectOperation.map.semantics@ to @ObjectsMapSemantics.LWW@
**** @(RTO11f4b)@ Set @ObjectOperation.map.entries@ to an empty map if @entries@ is omitted
**** @(RTO11f4c)@ Otherwise, set @ObjectOperation.map.entries@ based on the provided @entries@. For each key-value pair in @entries@:
***** @(RTO11f4c1)@ Create an @ObjectsMapEntry@ for the current value:
****** @(RTO11f4c1a)@ If the value is of type @LiveCounter@ or @LiveMap@, set @ObjectsMapEntry.data.objectId@ to the @objectId@ of that object
****** @(RTO11f4c1b)@ If the value is of type @JsonArray@ or @JsonObject@, set @ObjectsMapEntry.data.json@ to that value
****** @(RTO11f4c1c)@ If the value is of type @String@, set @ObjectsMapEntry.data.string@ to that value
****** @(RTO11f4c1d)@ If the value is of type @Number@, set @ObjectsMapEntry.data.number@ to that value
****** @(RTO11f4c1e)@ If the value is of type @Boolean@, set @ObjectsMapEntry.data.boolean@ to that value
****** @(RTO11f4c1f)@ If the value is of type @Binary@, set @ObjectsMapEntry.data.bytes@ to that value
***** @(RTO11f4c2)@ Add a new entry to @ObjectOperation.map.entries@ with the current key and the created @ObjectsMapEntry@ as the value
*** @(RTO11f5)@ Create an initial value JSON string as described in "RTO13":#RTO13, passing in the partial @ObjectOperation@ from "RTO11f4":#RTO11f4
*** @(RTO11f6)@ Create a unique string nonce with 16+ characters; the nonce is used to ensure object ID uniqueness across clients
*** @(RTO11f7)@ Get the current server time as described in "RTO16":#RTO16
*** @(RTO11f8)@ Create an @objectId@ for the new @LiveMap@ object as described in "RTO14":#RTO14, passing in @map@ string as the @type@, the initial value JSON string from "RTO11f5":#RTO11f5, the nonce from "RTO11f6":#RTO11f6, and the server time from "RTO11f7":#RTO11f7
*** @(RTO11f9)@ Set @ObjectMessage.operation.action@ to @ObjectOperationAction.MAP_CREATE@
*** @(RTO11f10)@ Set @ObjectMessage.operation.objectId@ to the @objectId@ created in "RTO11f8":#RTO11f8
*** @(RTO11f11)@ Set @ObjectMessage.operation.nonce@ to the nonce value created in "RTO11f6":#RTO11f6
*** @(RTO11f12)@ Set @ObjectMessage.operation.initialValue@ to the JSON string created in "RTO11f5":#RTO11f5
*** @(RTO11f13)@ Merge values from the partial @ObjectOperation@ created in "RTO11f4":#RTO11f4 into @ObjectMessage.operation@
** @(RTO11g)@ Publishes the @ObjectMessage@ from "RTO11f":#RTO11f using "@RealtimeObjects#publish@":#RTO15, passing the @ObjectMessage@ as a single element in the array
*** @(RTO11g1)@ The client library waits for the publish operation I/O to complete. On failure, an error is returned to the caller; on success, the @createMap@ operation continues
** @(RTO11h)@ Returns a @LiveMap@ instance:
*** @(RTO11h1)@ While waiting for the publish operation to complete in "RTO11g1":#RTO11g1, the client library may have already received the echoed @ObjectMessage@ operation, as it could arrive before the @ACK@ for the publish operation. Depending on the threading and/or asynchronous model of the client library, this could mean that the @ObjectMessage@ for the @MAP_CREATE@ operation has already been processed, and the new @LiveMap@ instance already exists in the internal @ObjectsPool@. As such, the following checks are performed to determine whether the instance already exists
*** @(RTO11h2)@ If an object with the @ObjectMessage.operation.objectId@ exists in the internal @ObjectsPool@, return it
*** @(RTO11h3)@ Otherwise, if the object does not exist in the internal @ObjectsPool@:
**** @(RTO11h3a)@ Create a zero-value @LiveMap@ (per "RTLM4":#RTLM4), set its @objectId@ to @ObjectMessage.operation.objectId@, set its @semantics@ to @ObjectMessage.operation.map.semantics@, and merge the initial value as described in "RTLM17":#RTLM17, passing in @ObjectMessage.operation@
**** @(RTO11h3b)@ Add the created @LiveMap@ instance to the internal @ObjectsPool@
**** @(RTO11h3c)@ Return the created @LiveMap@ instance
* @(RTO12)@ @RealtimeObjects#createCounter@ function:
** @(RTO12a)@ Expects the following arguments:
*** @(RTO12a1)@ @count@ @Number@ (optional) - the initial count for the new @LiveCounter@ object
** @(RTO12b)@ The return type is a @LiveCounter@, which is returned once the required I/O has successfully completed
** @(RTO12c)@ Requires the @OBJECT_PUBLISH@ channel mode to be granted per "RTO2":#RTO2
** @(RTO12d)@ If the channel is in the @DETACHED@, @FAILED@ or @SUSPENDED@ state, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 90001
** @(RTO12e)@ If "@echoMessages@":../features#TO3h client option is @false@, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 40000, indicating that @echoMessages@ must be enabled for this operation
** @(RTO12f)@ Creates an @ObjectMessage@ for a @COUNTER_CREATE@ action in the following way:
*** @(RTO12f1)@ If @count@ is null, not of type @Number@, or not a finite number, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 40003, indicating that @count@ must be a valid number. Note that @count@ is an optional argument, and if omitted, this error must not be thrown
*** @(RTO12f2)@ Create a partial @ObjectOperation@ with the initial value for the new @LiveCounter@:
**** @(RTO12f2a)@ Set @ObjectOperation.counter.count@ to 0 if @count@ is omitted
**** @(RTO12f2b)@ Otherwise, set @ObjectOperation.counter.count@ to the provided @count@ value
*** @(RTO12f3)@ Create an initial value JSON string as described in "RTO13":#RTO13, passing in the partial @ObjectOperation@ from "RTO12f2":#RTO12f2
*** @(RTO12f4)@ Create a unique string nonce with 16+ characters; the nonce is used to ensure object ID uniqueness across clients
*** @(RTO12f5)@ Get the current server time as described in "RTO16":#RTO16
*** @(RTO12f6)@ Create an @objectId@ for the new @LiveCounter@ object as described in "RTO14":#RTO14, passing in @counter@ string as the @type@, the initial value JSON string from "RTO12f3":#RTO12f3, the nonce from "RTO12f4":#RTO12f4, and the server time from "RTO12f5":#RTO12f5
*** @(RTO12f7)@ Set @ObjectMessage.operation.action@ to @ObjectOperationAction.COUNTER_CREATE@
*** @(RTO12f8)@ Set @ObjectMessage.operation.objectId@ to the @objectId@ created in "RTO12f6":#RTO12f6
*** @(RTO12f9)@ Set @ObjectMessage.operation.nonce@ to the nonce value created in "RTO12f4":#RTO12f4
*** @(RTO12f10)@ Set @ObjectMessage.operation.initialValue@ to the JSON string created in "RTO12f3":#RTO12f3
*** @(RTO12f11)@ Merge values from the partial @ObjectOperation@ created in "RTO12f2":#RTO12f2 into @ObjectMessage.operation@
** @(RTO12g)@ Publishes the @ObjectMessage@ from "RTO12f":#RTO12f using "@RealtimeObjects#publish@":#RTO15, passing the @ObjectMessage@ as a single element in the array
*** @(RTO12g1)@ The client library waits for the publish operation I/O to complete. On failure, an error is returned to the caller; on success, the @createCounter@ operation continues
** @(RTO12h)@ Returns a @LiveCounter@ instance:
*** @(RTO12h1)@ While waiting for the publish operation to complete in "RTO12g1":#RTO12g1, the client library may have already received the echoed @ObjectMessage@ operation, as it could arrive before the @ACK@ for the publish operation. Depending on the threading and/or asynchronous model of the client library, this could mean that the @ObjectMessage@ for the @COUNTER_CREATE@ operation has already been processed, and the new @LiveCounter@ instance already exists in the internal @ObjectsPool@. As such, the following checks are performed to determine whether the instance already exists
*** @(RTO12h2)@ If an object with the @ObjectMessage.operation.objectId@ exists in the internal @ObjectsPool@, return it
*** @(RTO12h3)@ Otherwise, if the object does not exist in the internal @ObjectsPool@:
**** @(RTO12h3a)@ Create a zero-value @LiveCounter@ (per "RTLC4":#RTLC4), set its @objectId@ to @ObjectMessage.operation.objectId@, and merge the initial value as described in "RTLC10":#RTLC10, passing in @ObjectMessage.operation@
**** @(RTO12h3b)@ Add the created @LiveCounter@ instance to the internal @ObjectsPool@
**** @(RTO12h3c)@ Return the created @LiveCounter@ instance
* @(RTO2)@ Certain object operations may require a specific channel mode to be set on a channel in order to be performed. If a specific channel mode is required by an operation, then:
** @(RTO2a)@ If the channel is in the @ATTACHED@ state, the presence of the required channel mode is checked against the set of channel modes granted by the server per "RTL4m":../features#RTL4m :
*** @(RTO2a1)@ If the channel mode is in the set, the operation is allowed
*** @(RTO2a2)@ If the channel mode is missing, unless otherwise specified by the operation, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 40024, indicating that the operation cannot be performed without the required channel mode
** @(RTO2b)@ Otherwise, a best-effort attempt is made, and the channel mode is checked against the set of channel modes requested by the user per "TB2d":../features#TB2d :
*** @(RTO2b1)@ If the channel mode is in the set, the operation is allowed
*** @(RTO2b2)@ If the channel mode is missing, unless otherwise specified by the operation, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 40024, indicating that the operation cannot be performed without the required channel mode
* @(RTO3)@ An internal @ObjectsPool@ should be used to maintain the list of objects present on a channel
** @(RTO3a)@ @ObjectsPool@ is a @Dict<String, LiveObject>@ - a map of @LiveObject@s keyed by "@objectId@":../features#OST2a string
** @(RTO3b)@ It must always contain a @LiveMap@ object with id @root@
*** @(RTO3b1)@ Upon initialization of the @ObjectsPool@, create a new @LiveMap@ (per "RTLM4":#RTLM4) with @objectId@ set to @root@ and add it to the @ObjectsPool@
* @(RTO4)@ When a channel @ATTACHED@ @ProtocolMessage@ is received, the @ProtocolMessage@ may contain a @HAS_OBJECTS@ bit flag indicating that it will perform an objects sync, see "TR3":../features#TR3 . Note that this does not imply that objects are definitely present on the channel, only that there may be; the @OBJECT_SYNC@ message may be empty
** @(RTO4a)@ If the @HAS_OBJECTS@ flag is 1, the server will shortly perform an @OBJECT_SYNC@ sequence as described in "RTO5":#RTO5
** @(RTO4b)@ If the @HAS_OBJECTS@ flag is 0 or there is no @flags@ field, the sync sequence must be considered complete immediately, and the client library must perform the following actions in order:
*** @(RTO4b1)@ All objects except the one with id @root@ must be removed from the internal @ObjectsPool@
*** @(RTO4b2)@ The data for the @LiveMap@ with id @root@ must be cleared by setting it to a zero-value per "RTLM4":#RTLM4. Note that the client SDK must not create a new @LiveMap@ instance with id @root@; it must only clear the internal data of the existing @LiveMap@ with id @root@
**** @(RTO4b2a)@ Emit a @LiveMapUpdate@ object for the @LiveMap@ with ID @root@, with @LiveMapUpdate.update@ consisting of entries for the keys that were removed, each set to @removed@
*** @(RTO4b3)@ The @SyncObjectsPool@ list must be cleared
*** @(RTO4b5)@ The @BufferedObjectOperations@ list must be cleared
*** @(RTO4b4)@ Perform the actions for objects sync completion as described in "RTO5c":#RTO5c
* @(RTO5)@ The realtime system reserves the right to initiate an objects sync of the objects on a channel at any point once a channel is attached. A server initiated objects sync provides Ably with a means to send a complete list of objects present on the channel at any point
** @(RTO5d)@ If an @OBJECT_SYNC@ @ProtocolMessage@ is received and "@ObjectMessage.object@":../features#TR4r is null or omitted, the client library should skip processing that @ProtocolMessage@
** @(RTO5a)@ When an @OBJECT_SYNC@ @ProtocolMessage@ is received with a @channel@ attribute matching the channel name, the client library must parse the @channelSerial@ attribute:
*** @(RTO5a1)@ The @channelSerial@ is used as the sync cursor and is a two-part identifier: @<sequence id>:<cursor value>@
*** @(RTO5a2)@ If a new sequence id is sent from Ably, the client library must treat it as the start of a new objects sync sequence, and any previous in-flight sync must be discarded:
**** @(RTO5a2a)@ The @SyncObjectsPool@ list must be cleared
**** @(RTO5a2b)@ The @BufferedObjectOperations@ list must be cleared
*** @(RTO5a3)@ If the sequence id matches the previously received sequence id, the client library should continue the sync process
*** @(RTO5a4)@ The objects sync sequence for that sequence identifier is considered complete once the cursor is empty; that is when the @channelSerial@ looks like @<sequence id>:@
*** @(RTO5a5)@ An @OBJECT_SYNC@ may also be sent with no @channelSerial@ attribute. In this case, the sync data is entirely contained within the @ProtocolMessage@
** @(RTO5b)@ During the sync sequence, the "@ObjectMessage.object@":../features#TR4r values from incoming @OBJECT_SYNC@ @ProtocolMessages@ must be temporarily stored in the internal @SyncObjectsPool@ list
** @(RTO5c)@ When the objects sync has completed, the client library must perform the following actions in order:
*** @(RTO5c1)@ For each @ObjectState@ in the @SyncObjectsPool@ list:
**** @(RTO5c1a)@ If an object with @ObjectState.objectId@ exists in the internal @ObjectsPool@:
***** @(RTO5c1a1)@ Replace the internal data for the object as described in "RTLC6":#RTLC6 or "RTLM6":#RTLM6 depending on the object type, passing in current @ObjectState@
***** @(RTO5c1a2)@ Store the @LiveObjectUpdate@ object returned by the operation, along with a reference to the updated object
**** @(RTO5c1b)@ If an object with @ObjectState.objectId@ does not exist in the internal @ObjectsPool@:
***** @(RTO5c1b1)@ Create a new @LiveObject@ using the data from @ObjectState@ and add it to the internal @ObjectsPool@:
****** @(RTO5c1b1a)@ If @ObjectState.counter@ is present, create a zero-value @LiveCounter@ (per "RTLC4":#RTLC4), set its private @objectId@ equal to @ObjectState.objectId@ and replace its internal data using the current @ObjectState@ per "RTLC6":#RTLC6
****** @(RTO5c1b1b)@ If @ObjectState.map@ is present, create a zero-value @LiveMap@ (per "RTLM4":#RTLM4), set its private @objectId@ equal to @ObjectState.objectId@, set its private @semantics@ equal to @ObjectState.map.semantics@ and replace its internal data using the current @ObjectState@ per "RTLM6":#RTLM6
****** @(RTO5c1b1c)@ Otherwise, log a warning that an unsupported object state message has been received, and discard the current @ObjectState@ without taking any action
*** @(RTO5c2)@ Remove any objects from the internal @ObjectsPool@ for which @objectId@s were not received during the sync sequence
**** @(RTO5c2a)@ The object with ID @root@ must not be removed from @ObjectsPool@, as per "RTO3b":#RTO3b
*** @(RTO5c7)@ For each previously existing object that was updated as a result of "RTO5c1a":#RTO5c1a, emit the corresponding stored @LiveObjectUpdate@ object from "RTO5c1a2":#RTO5c1a2
*** @(RTO5c6)@ @ObjectMessages@ stored in the @BufferedObjectOperations@ list are applied as described in "RTO9":#RTO9
*** @(RTO5c3)@ Clear any stored sync sequence identifiers and cursor values
*** @(RTO5c4)@ The @SyncObjectsPool@ must be cleared
*** @(RTO5c5)@ The @BufferedObjectOperations@ list must be cleared
* @(RTO6)@ Certain object operations may require creating a zero-value object if one does not already exist in the internal @ObjectsPool@ for the given @objectId@. This can be done as follows:
** @(RTO6a)@ If an object with @objectId@ exists in @ObjectsPool@, do not create a new object
** @(RTO6b)@ The expected type of the object can be inferred from the provided @objectId@:
*** @(RTO6b1)@ Split the @objectId@ (formatted as @[type]:[hash]&#64;[timestamp]@, see "RTO14c":#RTO14c) on the separator @:@ and parse the first part as the type string
*** @(RTO6b2)@ If the parsed type is @map@, create a zero-value @LiveMap@ per "RTLM4":#RTLM4 in the @ObjectsPool@
*** @(RTO6b3)@ If the parsed type is @counter@, create a zero-value @LiveCounter@ per "RTLC4":#RTLC4 in the @ObjectsPool@
* @(RTO7)@ The client library may receive @OBJECT@ @ProtocolMessages@ in realtime over the channel concurrently with @OBJECT_SYNC@ @ProtocolMessages@ during the object sync sequence ("RTO5":#RTO5). Some of the incoming @OBJECT@ messages may have already been applied to the objects described in the sync sequence, while others may not. Therefore, the client must buffer @OBJECT@ messages during the sync sequence so that it can determine which of them should be applied to the objects once the sync is complete. See "RTO8":#RTO8
** @(RTO7a)@ An internal @BufferedObjectOperations@ should be used to store the buffered @ObjectMessages@, as described in "RTO8a":#RTO8a. @BufferedObjectOperations@ is an array of @ObjectMessage@ instances
*** @(RTO7a1)@ This array is empty upon @RealtimeObjects@ initialization
* @(RTO8)@ When the library receives a @ProtocolMessage@ with an action of @OBJECT@, each member of the @ProtocolMessage.state@ array (decoded into @ObjectMessage@ objects) is passed to the @RealtimeObjects@ instance per "RTL1":../features#RTL1. Each @ObjectMessage@ from @OBJECT@ @ProtocolMessage@ (also referred to as an @OBJECT@ message) describes an operation to be applied to an object on a channel and must be handled as follows:
** @(RTO8a)@ If an object sync sequence is currently in progress, add the @ObjectMessages@ to the internal @BufferedObjectOperations@ array
** @(RTO8b)@ Otherwise, apply the @ObjectMessages@ as described in "RTO9":#RTO9
* @(RTO9)@ @OBJECT@ messages can be applied to @RealtimeObjects@ in the following way:
** @(RTO9a)@ For each @ObjectMessage@ in the provided list:
*** @(RTO9a1)@ If @ObjectMessage.operation@ is null or omitted, log a warning indicating that an unsupported object operation message has been received, and discard the current @ObjectMessage@ without taking any action
*** @(RTO9a2)@ The @ObjectMessage.operation.action@ field (see "@ObjectOperationAction@":../features#OOP2) determines the type of operation to apply:
**** @(RTO9a2a)@ If @ObjectMessage.operation.action@ is one of the following: @MAP_CREATE@, @MAP_SET@, @MAP_REMOVE@, @COUNTER_CREATE@, @COUNTER_INC@, or @OBJECT_DELETE@, then:
***** @(RTO9a2a1)@ If it does not already exist, create a zero-value @LiveObject@ in the internal @ObjectsPool@ per "RTO6":#RTO6 using the @objectId@ from @ObjectMessage.operation.objectId@
***** @(RTO9a2a2)@ Get the @LiveObject@ instance from the internal @ObjectsPool@ using the @objectId@ from @ObjectMessage.operation.objectId@
***** @(RTO9a2a3)@ Apply the @ObjectMessage.operation@ to the @LiveObject@; see "RTLC7":#RTLC7, "RTLM15":#RTLM15
**** @(RTO9a2b)@ Otherwise, log a warning that an object operation message with an unsupported action has been received, and discard the current @ObjectMessage@ without taking any action
* @(RTO10)@ The client library must have a process in place to regularly check for objects and map entries that have been tombstoned for a period of time, and release their resources so they can be garbage collected. Tombstoned objects and map entries are retained in memory for a sufficient grace period (at least >2 minutes) to ensure that no late-arriving operation is mistakenly applied to an object or map entry the client has already "forgotten" about.
** @(RTO10a)@ The check should occur at regular intervals, for example, every 5 minutes
** @(RTO10b)@ The grace period for releasing resources for tombstoned objects and map entries is determined as follows:
*** @(RTO10b1)@ It is equal to "@ConnectionDetails.objectsGCGracePeriod@":../features#CD2i received in the @CONNECTED@ @ProtocolMessage@
*** @(RTO10b2)@ The grace period value is updated to match the new @ConnectionDetails.objectsGCGracePeriod@ value whenever a new @CONNECTED@ @ProtocolMessage@ is received per "RTN24":../features#RTN24
*** @(RTO10b3)@ A default value of 86,400,000 milliseconds (24 hours) is used if @ConnectionDetails.objectsGCGracePeriod@ is not provided
** @(RTO10c)@ On each check interval:
*** @(RTO10c1)@ For each @LiveObject@ in the @ObjectsPool@:
**** @(RTO10c1a)@ Check if the @LiveObject@ needs to release any resources, see "RTLM19":#RTLM19
**** @(RTO10c1b)@ If @LiveObject.isTombstone@ is @true@, and the difference between the current time and @LiveObject.tombstonedAt@ is greater than or equal to the "grace period":#RTO10b, remove the object from the @ObjectsPool@ and release resources for the corresponding object entity to allow it to be garbage collected
* @(RTO13)@ The initial value JSON string can be created from a partial @ObjectOperation@ in the following way:
** @(RTO13a)@ Expects the following arguments:
*** @(RTO13a1)@ @ObjectOperation@
** @(RTO13b)@ The @ObjectOperation@ may contain user-provided @ObjectData@ that requires encoding. For example, binary data must be encoded to ensure it can be correctly represented in a JSON string and parsed by the Ably server. Therefore, create an encoded instance of @ObjectOperation@ using the same encoding procedure described for the @ObjectMessage@ in "OM4":../features#OM4
** @(RTO13c)@ Return a JSON string representation of the encoded @ObjectOperation@
* @(RTO14)@ An Object ID can be created in the client library for a new @LiveObject@ instance in the following way:
** @(RTO14a)@ Expects the following arguments:
*** @(RTO14a1)@ @type@ @String@ - the type of object this Object ID is generated for. Must be one of @map@ or @counter@
*** @(RTO14a2)@ @initialValue@ @String@ - a JSON string representation of the initial value for the object, based on the encoded @ObjectOperation@. This protects against Object IDs being reused for create operations with differing content
*** @(RTO14a3)@ @nonce@ @String@ - a random string to ensure uniqueness across clients
*** @(RTO14a4)@ @timestamp@ @Time@ - the current server time. This protects against Object IDs being reused across time
** @(RTO14b)@ Generate a @hash@ string for the Object ID:
*** @(RTO14b1)@ Generate a SHA-256 digest from a UTF-8 encoded string in the format @[initialValue]:[nonce]@
*** @(RTO14b2)@ Base64URL-encode the generated digest. This must follow the URL-safe Base64 encoding as described in "RFC 4648 s.5":https://datatracker.ietf.org/doc/html/rfc4648#section-5, not standard Base64 encoding
** @(RTO14c)@ Return an Object ID in the format @[type]:[hash]&#64;[timestamp]@, where @timestamp@ is represented as milliseconds since the epoch
* @(RTO15)@ Internal @RealtimeObjects#publish@ function:
** @(RTO15a)@ Expects the following arguments:
*** @(RTO15a1)@ @ObjectMessage[]@ - an array of @ObjectMessage@ to be published on a channel
** @(RTO15b)@ Must adhere to the same connection and channel state conditions as message publishing, see "RTL6c":../features#RTL6c
** @(RTO15c)@ Must encode the provided @ObjectMessages@ as described in "OM4":../features#OM4
** @(RTO15d)@ Should validate that the total size of the encoded @ObjectMessages@, calculated as per "OM3":../features#OM3, does not exceed "@maxMessageSize@":#TO3l8. If it does, the client library must reject the publish and throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 40009
** @(RTO15e)@ Must construct the following @ProtocolMessage@:
*** @(RTO15e1)@ Set @ProtocolMessage.action@ to @OBJECT@
*** @(RTO15e2)@ Set @ProtocolMessage.channel@ to the channel name
*** @(RTO15e3)@ Set @ProtocolMessage.state@ to the encoded @ObjectMessages@
** @(RTO15f)@ Must send the @ProtocolMessage@ to the connection
** @(RTO15g)@ Must indicate success or failure of the publish (once @ACKed@ or @NACKed@) in the same way as @RealtimeChannel#publish@
* @(RTO16)@ Server time can be retrieved using "@RestClient#time@":../features#RSC16
** @(RTO16a)@ The server time offset can be persisted by the client library and used to calculate the server time without making a request, in a similar way to how it is described in "RSA10k":../features#RSA10k. The persisted offset from either operation can be used interchangeably

h3(#liveobject). LiveObject

* @(RTLO1)@ The @LiveObject@ represents the common interface and includes shared functionality for concrete object types
* @(RTLO2)@ The client library may choose to implement @LiveObject@ as an abstract class
* @(RTLO3)@ @LiveObject@ properties:
** @(RTLO3a)@ protected @objectId@ string - an Object ID for this object
*** @(RTLO3a1)@ Must be provided and set in the constructor
** @(RTLO3b)@ protected @siteTimeserials@ @Dict<String, String>@ - a map of "serials":../features#OM2h keyed by "siteCode":../features#OM2i, representing the last operations applied to this object
*** @(RTLO3b1)@ Set to an empty map when the @LiveObject@ is initialized, so that any future operation can be applied to this object
** @(RTLO3c)@ protected @createOperationIsMerged@ boolean - a flag indicating whether the corresponding @MAP_CREATE@ or @COUNTER_CREATE@ operation has been applied to this @LiveObject@ instance
*** @(RTLO3c1)@ Set to @false@ when the @LiveObject@ is initialized
** @(RTLO3d)@ protected @isTombstone@ boolean - a flag indicating whether this object has been tombstoned, i.e. marked for deletion from the objects pool
*** @(RTLO3d1)@ Set to @false@ when the @LiveObject@ is initialized
** @(RTLO3e)@ protected @tombstonedAt@ (optional) Time - a timestamp indicating when this object was tombstoned. This property is nullable, and specification points that manipulate this value maintain the invariant that it is non-null if and only if @isTombstone@ is @true@
*** @(RTLO3e1)@ Set to undefined/null when the @LiveObject@ is initialized
* @(RTLO4)@ @LiveObject@ methods:
** @(RTLO4b)@ public @subscribe@ - subscribes a user to data updates on this @LiveObject@ instance
*** @(RTLO4b1)@ Requires the @OBJECT_SUBSCRIBE@ channel mode to be granted per "RTO2":#RTO2
*** @(RTLO4b2)@ If the channel is in the @DETACHED@ or @FAILED@ state, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 90001
*** @(RTLO4b3)@ A user may provide a listener to subscribe to data updates on this @LiveObject@ instance
*** @(RTLO4b4)@ An update to @LiveObject@ data is communicated by internally emitting a @LiveObjectUpdate@ object for this @LiveObject@, or in any other platform-appropriate manner:
**** @(RTLO4b4a)@ @LiveObjectUpdate.update@ contains the specific information about what was changed on the object. The exact type depends on the object type
**** @(RTLO4b4b)@ The @LiveObjectUpdate.noop@ internal property can be used to indicate that the update was a no-op
**** @(RTLO4b4c)@ When a @LiveObjectUpdate@ is emitted:
***** @(RTLO4b4c1)@ If @LiveObjectUpdate@ is indicated to be a no-op, do nothing
***** @(RTLO4b4c2)@ Otherwise, the registered listener is called with the @LiveObjectUpdate@ object
*** @(RTLO4b5)@ The client library may return a subscription object (or the idiomatic equivalent for the language) as a result of this operation:
**** @(RTLO4b5a)@ The subscription object includes an @unsubscribe@ function
**** @(RTLO4b5b)@ Calling @unsubscribe@ deregisters the listener previously registered by the user via the corresponding @subscribe@ call
*** @(RTLO4b6)@ This operation must not have any side effects on @RealtimeObjects@, the underlying channel, or their status
** @(RTLO4c)@ public @unsubscribe@ - unsubscribes a previously registered listener
*** @(RTLO4c1)@ This operation does not require any specific channel modes to be granted, nor does it require the channel to be in a specific state
*** @(RTLO4c2)@ A user may provide a listener they wish to deregister from receiving data updates for this @LiveObject@
*** @(RTLO4c3)@ Once deregistered, subsequent data updates for this @LiveObject@ must not result in the listener being called
*** @(RTLO4c4)@ This operation must not have any side effects on @RealtimeObjects@, the underlying channel, or their status
** @(RTLO4d)@ public @unsubscribeAll@ - unsubscribes all previously registered listeners
*** @(RTLO4d1)@ This operation does not require any specific channel modes to be granted, nor does it require the channel to be in a specific state
*** @(RTLO4d2)@ Deregisters all current data update listeners from receiving any further events for this @LiveObject@
*** @(RTLO4d3)@ Once deregistered, subsequent data updates for this @LiveObject@ must not result in any of the previously registered listeners being called
*** @(RTLO4d4)@ This operation must not have any side effects on @RealtimeObjects@, the underlying channel, or their status
** @(RTLO4a)@ protected @canApplyOperation@ - a convenience method used to determine whether the @ObjectMessage.operation@ should be applied to this object based on a serial value
*** @(RTLO4a1)@ Expects the following arguments:
**** @(RTLO4a1a)@ @ObjectMessage@
*** @(RTLO4a2)@ Returns a boolean indicating whether the operation should be applied to this object
*** @(RTLO4a3)@ Both @ObjectMessage.serial@ and @ObjectMessage.siteCode@ must be non-empty strings. Otherwise, log a warning that the object operation message has invalid serial values. The client library must not apply this operation to the object
*** @(RTLO4a4)@ Get the @siteSerial@ value stored for this @LiveObject@ in the @siteTimeserials@ map using the key @ObjectMessage.siteCode@
*** @(RTLO4a5)@ If the @siteSerial@ for this @LiveObject@ is null or an empty string, return true
*** @(RTLO4a6)@ If the @siteSerial@ for this @LiveObject@ is not an empty string, return true if @ObjectMessage.serial@ is greater than @siteSerial@ when compared lexicographically
** @(RTLO4e)@ protected @tombstone@ - a convenience method used to tombstone this @LiveObject@. The realtime system reserves the right to tombstone an object (i.e. mark it for deletion from the objects pool) by publishing an @OBJECT_DELETE@ operation at any time if the object is orphaned (not a descendant of the root object) or remains uninitialized (no @*_CREATE@ operation has been received) for an extended period. Only the realtime system may publish an @OBJECT_DELETE@ operation; clients must never send it. This method describes the steps the client library must take when it needs to tombstone an object locally. Eventually, tombstoned objects will be garbage collected following the procedure described in "RTO10":#RTO10
*** @(RTLO4e1)@ Expects the following arguments:
**** @(RTLO4e1a)@ @ObjectMessage@
*** @(RTLO4e2)@ Set @LiveObject.isTombstone@ to @true@
*** @(RTLO4e3)@ Set @LiveObject.tombstonedAt@ as follows:
**** @(RTLO4e3a)@ Set it equal to @ObjectMessage.serialTimestamp@ if it exists
**** @(RTLO4e3b)@ Otherwise, set it to the current time using the local clock
***** @(RTLO4e3b1)@ Log a debug or trace message indicating that @serialTimestamp@ was not found in the message and the local clock is being used instead for the tombstone timestamp
*** @(RTLO4e4)@ Set the data for the @LiveObject@ to a zero-value, as described in "RTLC4":#RTLC4 or "RTLM4":#RTLM4 depending on the object type
* @(RTLO5)@ An @OBJECT_DELETE@ operation can be applied to a @LiveObject@ in the following way:
** @(RTLO5a)@ Expects the following arguments:
*** @(RTLO5a1)@ @ObjectMessage@
** @(RTLO5b)@ Tombstone the current @LiveObject@ using "@LiveObject.tombstone@":#RTLO4e, passing in the @ObjectMessage@

h3(#livecounter). LiveCounter

* @(RTLC1)@ The @LiveCounter@ extends @LiveObject@
* @(RTLC2)@ Represents the counter object type for Object IDs of type @counter@
* @(RTLC3)@ Holds a 64-bit floating-point number as a private @data@
* @(RTLC4)@ The zero-value @LiveCounter@ is a @LiveCounter@ with @data@ set to 0
* @(RTLC11)@ Data updates for a @LiveCounter@ are emitted using the @LiveCounterUpdate@ object:
** @(RTLC11a)@ @LiveCounterUpdate@ extends @LiveObjectUpdate@
** @(RTLC11b)@ @LiveCounterUpdate.update@ has the following properties:
*** @(RTLC11b1)@ @amount@ number - the value by which the counter was incremented or decremented
* @(RTLC5)@ @LiveCounter#value@ function:
** @(RTLC5a)@ Requires the @OBJECT_SUBSCRIBE@ channel mode to be granted per "RTO2":#RTO2
** @(RTLC5b)@ If the channel is in the @DETACHED@ or @FAILED@ state, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 90001
** @(RTLC5c)@ Returns the current @data@ value
* @(RTLC12)@ @LiveCounter#increment@ function:
** @(RTLC12a)@ Expects the following arguments:
*** @(RTLC12a1)@ @amount@ @Number@ - the amount by which to increment the counter value
** @(RTLC12b)@ Requires the @OBJECT_PUBLISH@ channel mode to be granted per "RTO2":#RTO2
** @(RTLC12c)@ If the channel is in the @DETACHED@, @FAILED@ or @SUSPENDED@ state, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 90001
** @(RTLC12d)@ If "@echoMessages@":../features#TO3h client option is @false@, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 40000, indicating that @echoMessages@ must be enabled for this operation
** @(RTLC12e)@ Creates an @ObjectMessage@ for a @COUNTER_INC@ action in the following way:
*** @(RTLC12e1)@ If @amount@ is null, not of type @Number@, not a finite number, or omitted, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 40003, indicating that @amount@ must be a valid number
*** @(RTLC12e2)@ Set @ObjectMessage.operation.action@ to @ObjectOperationAction.COUNTER_INC@
*** @(RTLC12e3)@ Set @ObjectMessage.operation.objectId@ to the Object ID of this @LiveCounter@
*** @(RTLC12e4)@ Set @ObjectMessage.operation.counterOp.amount@ to the provided @amount@ value
** @(RTLC12f)@ Publishes the @ObjectMessage@ from "RTLC12e":#RTLC12e using "@RealtimeObjects#publish@":#RTO15, passing the @ObjectMessage@ as a single element in the array
* @(RTLC13)@ @LiveCounter#decrement@ function:
** @(RTLC13a)@ Expects the following arguments:
*** @(RTLC13a1)@ @amount@ @Number@ - the amount by which to decrement the counter value
** @(RTLC13b)@ This is an alias for calling "@LiveCounter#increment@":#RTLC12 with a negative @amount@ and must be implemented with the same behavior
** @(RTLC13c)@ If the client library chooses to delegate to @LiveCounter#increment@ with a negated @amount@, then in languages where negating a non-number may result in implicit type coercion, the @amount@ argument must first be validated as described in "RTLC12e1":#RTLC12e1 before proceeding
* @(RTLC6)@ @LiveCounter@'s internal @data@ can be replaced with the provided @ObjectState@ in the following way:
** @(RTLC6a)@ Replace the private @siteTimeserials@ of the @LiveCounter@ with the value from @ObjectState.siteTimeserials@
** @(RTLC6e)@ If @LiveCounter.isTombstone@ is @true@, finish processing the @ObjectState@
*** @(RTLC6e1)@ Return a @LiveCounterUpdate@ object with @LiveCounterUpdate.noop@ set to @true@, indicating that no update was made to the object
** @(RTLC6f)@ If @ObjectState.tombstone@ is @true@, tombstone the current @LiveCounter@ using "@LiveObject.tombstone@":#RTLO4e, passing in the outer @ObjectMessage@ for the @ObjectState@. Finish processing the @ObjectState@
*** @(RTLC6f1)@ Return a @LiveCounterUpdate@ object with @LiveCounterUpdate.update.amount@ set to the negative @data@ value that this @LiveCounter@ had before being tombstoned
** @(RTLC6b)@ Set the private flag @createOperationIsMerged@ to @false@
** @(RTLC6c)@ Set @data@ to the value of @ObjectState.counter.count@, or to 0 if it does not exist
** @(RTLC6d)@ If @ObjectState.createOp@ is present, merge the initial value into the @LiveCounter@ as described in "RTLC10":#RTLC10, passing in the @ObjectState.createOp@ instance
*** @(RTLC6d1)@ This clause has been replaced by "RTLC10a":#RTLC10a
*** @(RTLC6d2)@ This clause has been replaced by "RTLC10b":#RTLC10b
** @(RTLC6g)@ Return a @LiveCounterUpdate@ object that reflects the change in value caused by applying "RTLC6":#RTLC6. Construct the update using the procedure defined in "RTLC14":#RTLC14, passing in the @previous@ @data@ value that the @LiveCounter@ had before applying "RTLC6":#RTLC6, and the @new@ @data@ value that the @LiveCounter@ has after applying "RTLC6d":#RTLC6d
* @(RTLC7)@ An @ObjectOperation@ from @ObjectMessage.operation@ can be applied to a @LiveCounter@ by performing the following actions in order:
** @(RTLC7a)@ A client library may choose to implement this logic as a convenience method named @applyOperation@, which accepts an @ObjectMessage@ instance with an existing @ObjectMessage.operation@ object, with @ObjectMessage.operation.objectId@ matching the Object ID of this @LiveCounter@. This @ObjectMessage@ represents the operation to be applied to this @LiveCounter@
** @(RTLC7b)@ If @ObjectMessage.operation@ cannot be applied based on the result of "@LiveObject.canApplyOperation@":#RTLO4a, log a debug or trace message indicating that the operation cannot be applied because its serial value is not newer than the object's, and discard the @ObjectMessage@ without taking any further action
** @(RTLC7c)@ Set the entry in the private @siteTimeserials@ map at the key @ObjectMessage.siteCode@ to equal @ObjectMessage.serial@
** @(RTLC7e)@ If @LiveCounter.isTombstone@ is @true@, the operation cannot be applied to the object. Finish processing the @ObjectMessage@ without taking any further action. No data update event is emitted
** @(RTLC7d)@ The @ObjectMessage.operation.action@ field (see "@ObjectOperationAction@":../features#OOP2) determines the type of operation to apply:
*** @(RTLC7d1)@ If @ObjectMessage.operation.action@ is set to @COUNTER_CREATE@, apply the operation as described in "RTLC8":#RTLC8, passing in @ObjectMessage.operation@
**** @(RTLC7d1a)@ Emit the @LiveCounterUpdate@ object returned as a result of applying the operation
*** @(RTLC7d2)@ If @ObjectMessage.operation.action@ is set to @COUNTER_INC@, apply the operation as described in "RTLC9":#RTLC9, passing in @ObjectMessage.operation.counterOp@
**** @(RTLC7d2a)@ Emit the @LiveCounterUpdate@ object returned as a result of applying the operation
*** @(RTLC7d4)@ If @ObjectMessage.operation.action@ is set to @OBJECT_DELETE@, apply the operation as described in "RTLO5":#RTLO5, passing in @ObjectMessage@
**** @(RTLC7d4a)@ Emit a @LiveCounterUpdate@ object after applying the @OBJECT_DELETE@ operation, with @LiveCounterUpdate.update.amount@ set to the negated value that this @LiveCounter@ held before the operation was applied
*** @(RTLC7d3)@ Otherwise, log a warning that an object operation message with an unsupported action has been received, and discard the current @ObjectMessage@ without taking any further action. No data update event is emitted
* @(RTLC8)@ A @COUNTER_CREATE@ operation can be applied to a @LiveCounter@ in the following way:
** @(RTLC8a)@ Expects the following arguments:
*** @(RTLC8a1)@ @ObjectOperation@
** @(RTLC8d)@ The return type is a @LiveCounterUpdate@ object, which indicates the data update for this @LiveCounter@
** @(RTLC8b)@ If the private flag @createOperationIsMerged@ is @true@, log a debug or trace message indicating that the operation will not be applied because a @COUNTER_CREATE@ operation has already been applied to this @LiveCounter@. Discard the operation without taking any further action, and return a @LiveCounterUpdate@ object with @LiveCounterUpdate.noop@ set to @true@, indicating that no update was made to the object
** @(RTLC8c)@ Otherwise merge the initial value into the @LiveCounter@ as described in "RTLC10":#RTLC10, passing in the @ObjectOperation@ instance
** @(RTLC8e)@ Return the @LiveCounterUpdate@ object returned by "RTLC10":#RTLC10
* @(RTLC9)@ A @COUNTER_INC@ operation can be applied to a @LiveCounter@ in the following way:
** @(RTLC9a)@ Expects the following arguments:
*** @(RTLC9a1)@ @ObjectsCounterOp@
** @(RTLC9c)@ The return type is a @LiveCounterUpdate@ object, which indicates the data update for this @LiveCounter@
** @(RTLC9b)@ Add @ObjectsCounterOp.amount@ to @data@, if it exists
** @(RTLC9d)@ If @ObjectsCounterOp.amount@ exists, return a @LiveCounterUpdate@ object with @LiveCounterUpdate.update.amount@ set to @ObjectsCounterOp.amount@
** @(RTLC9e)@ If @ObjectsCounterOp.amount@ does not exist, return a @LiveCounterUpdate@ object with @LiveCounterUpdate.noop@ set to @true@
* @(RTLC10)@ The initial value from @ObjectOperation.counter@ can be merged into this @LiveCounter@ in the following way:
** @(RTLC10a)@ Add @ObjectOperation.counter.count@ to @data@, if it exists
** @(RTLC10b)@ Set the private flag @createOperationIsMerged@ to @true@
** @(RTLC10c)@ If @ObjectOperation.counter.count@ exists, return a @LiveCounterUpdate@ object with @LiveCounterUpdate.update.amount@ set to @ObjectOperation.counter.count@
** @(RTLC10d)@ If @ObjectOperation.counter.count@ does not exist, return a @LiveCounterUpdate@ object with @LiveCounterUpdate.noop@ set to @true@
* @(RTLC14)@ A @LiveCounterUpdate@ for the difference between two @LiveCounter@ @data@ values (referred to as "previous" and "new" values) can be created using the convenience method:
** @(RTLC14a)@ Expects the following arguments:
*** @(RTLC14a1)@ @previous@ number
*** @(RTLC14a2)@ @new@ number
** @(RTLC14b)@ The return type is a @LiveCounterUpdate@ object, which indicates the data update for this @LiveCounter@
** @(RTLC14c)@ Return a @LiveCounterUpdate@ object with @LiveCounterUpdate.update.amount@ equal to the difference between the @new@ and @previous@ values

h3(#livemap). LiveMap

* @(RTLM1)@ The @LiveMap@ extends @LiveObject@
* @(RTLM2)@ Represents the map object type for Object IDs of type @map@
* @(RTLM3)@ Holds a @Dict<String, ObjectsMapEntry>@ as a private @data@ map
** @(RTLM3a)@ @ObjectsMapEntry@ entries in a @LiveMap@ have the following attributes in addition to those defined in "OME2":../features#OME2:
*** @(RTLM3a1)@ @tombstonedAt@ (optional) Time - a timestamp indicating when this map entry was tombstoned. This property is nullable, and specification points that manipulate this value maintain the invariant that it is non-null if and only if the corresponding @ObjectsMapEntry.tombstone@ is @true@
* @(RTLM4)@ The zero-value @LiveMap@ is a @LiveMap@ with @data@ set to an empty map
* @(RTLM18)@ Data updates for a @LiveMap@ are emitted using the @LiveMapUpdate@ object:
** @(RTLM18a)@ @LiveMapUpdate@ extends @LiveObjectUpdate@
** @(RTLM18b)@ @LiveMapUpdate.update@ is of type @Dict<String, 'updated' | 'removed'>@ - a map of @LiveMap@ keys that were either updated or removed, with the corresponding value indicating the type of change for each key
* @(RTLM5)@ @LiveMap#get@ function:
** @(RTLM5a)@ Accepts a key of type String
** @(RTLM5b)@ Requires the @OBJECT_SUBSCRIBE@ channel mode to be granted per "RTO2":#RTO2
** @(RTLM5c)@ If the channel is in the @DETACHED@ or @FAILED@ state, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 90001
** @(RTLM5e)@ If @LiveMap.isTombstone@ is @true@, return undefined/null
** @(RTLM5d)@ Returns the value from the current @data@ at the specified key, as follows:
*** @(RTLM5d1)@ If no @ObjectsMapEntry@ exists at the key, return undefined/null
*** @(RTLM5d2)@ If an @ObjectsMapEntry@ exists at the key:
**** @(RTLM5d2a)@ If @ObjectsMapEntry.tombstone@ is @true@, return undefined/null
**** @(RTLM5d2b)@ If @ObjectsMapEntry.data.boolean@ exists, return it
**** @(RTLM5d2c)@ If @ObjectsMapEntry.data.bytes@ exists, return it
**** @(RTLM5d2d)@ If @ObjectsMapEntry.data.number@ exists, return it
**** @(RTLM5d2e)@ If @ObjectsMapEntry.data.string@ exists, return it
**** @(RTLM5d2f)@ If @ObjectsMapEntry.data.objectId@ exists, get the object stored at that @objectId@ from the internal @ObjectsPool@:
***** @(RTLM5d2f1)@ If an object with id @objectId@ does not exist, return undefined/null
***** @(RTLM5d2f3)@ If an object with id @objectId@ exists and its @LiveObject.isTombstone@ is @true@, return undefined/null
***** @(RTLM5d2f2)@ Otherwise, return the object with id @objectId@
**** @(RTLM5d2g)@ Otherwise, return undefined/null
* @(RTLM10)@ @LiveMap#size@:
** @(RTLM10a)@ A method or property, depending on what is more idiomatic for the platform to use for a Map/Dictionary interface. For example, in JavaScript, this is a property similar to @Map.size@ for the native @Map@ class
** @(RTLM10b)@ Requires the @OBJECT_SUBSCRIBE@ channel mode to be granted per "RTO2":#RTO2
** @(RTLM10c)@ If the channel is in the @DETACHED@ or @FAILED@ state, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 90001
** @(RTLM10d)@ Returns the number of non-tombstoned entries (per "RTLM14":#RTLM14) in the internal @data@ map
* @(RTLM11)@ @LiveMap#entries@:
** @(RTLM11a)@ A method or property, depending on what is more idiomatic for the platform to use for a Map/Dictionary interface. For example, in JavaScript, this is a method similar to @Map.entries()@ for the native @Map@ class
** @(RTLM11b)@ Requires the @OBJECT_SUBSCRIBE@ channel mode to be granted per "RTO2":#RTO2
** @(RTLM11c)@ If the channel is in the @DETACHED@ or @FAILED@ state, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 90001
** @(RTLM11d)@ Returns key-value pairs from the internal @data@ map:
*** @(RTLM11d1)@ Pairs with tombstoned entries (per "RTLM14":#RTLM14) are not returned
*** @(RTLM11d3)@ @ObjectsMapEntry@ values are mapped to user-facing values following the same procedure as in "RTLM5d2":#RTLM5d2
**** @(RTLM11d3a)@ Note that if "RTLM5d2":#RTLM5d2 results in an @ObjectsMapEntry@ being mapped to an undefined/null value, the corresponding key-value pair is still returned by this @LiveMap#entries@ call
*** @(RTLM11d2)@ The return type is idiomatic for the platform's analogous Map/Dictionary interface operation. For example, in JavaScript, it returns a map iterator object like the one returned by @Map.entries()@ method for the native @Map@ class
* @(RTLM12)@ @LiveMap#keys@:
** @(RTLM12a)@ A method or property, depending on what is more idiomatic for the platform to use for a Map/Dictionary interface. For example, in JavaScript, this is a method similar to @Map.keys()@ for the native @Map@ class
** @(RTLM12b)@ The implementation is identical to @LiveMap#entries@, except that it returns only the keys from the internal @data@ map
* @(RTLM13)@ @LiveMap#values@:
** @(RTLM13a)@ A method or property, depending on what is more idiomatic for the platform to use for a Map/Dictionary interface. For example, in JavaScript, this is a method similar to @Map.values()@ for the native @Map@ class
** @(RTLM13b)@ The implementation is identical to @LiveMap#entries@, except that it returns only the values from the internal @data@ map
* @(RTLM20)@ @LiveMap#set@ function:
** @(RTLM20a)@ Expects the following arguments:
*** @(RTLM20a1)@ @key@ @String@ - the key to set the value for
*** @(RTLM20a2)@ @value@ @Boolean | Binary | Number | String | JsonArray | JsonObject | LiveCounter | LiveMap@ - the value to assign to the key
** @(RTLM20b)@ Requires the @OBJECT_PUBLISH@ channel mode to be granted per "RTO2":#RTO2
** @(RTLM20c)@ If the channel is in the @DETACHED@, @FAILED@ or @SUSPENDED@ state, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 90001
** @(RTLM20d)@ If "@echoMessages@":../features#TO3h client option is @false@, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 40000, indicating that @echoMessages@ must be enabled for this operation
** @(RTLM20e)@ Creates an @ObjectMessage@ for a @MAP_SET@ action in the following way:
*** @(RTLM20e1)@ Validates the provided @key@ and @value@ in a similar way as described in "RTO11f2":#RTO11f2 and "RTO11f3":#RTO11f3
*** @(RTLM20e2)@ Set @ObjectMessage.operation.action@ to @ObjectOperationAction.MAP_SET@
*** @(RTLM20e3)@ Set @ObjectMessage.operation.objectId@ to the Object ID of this @LiveMap@
*** @(RTLM20e4)@ Set @ObjectMessage.operation.mapOp.key@ to the provided @key@ value
*** @(RTLM20e5)@ Set @ObjectMessage.operation.mapOp.data@ depending on the type of the provided @value@:
**** @(RTLM20e5a)@ If the @value@ is of type @LiveCounter@ or @LiveMap@, set @ObjectMessage.operation.mapOp.data.objectId@ to the @objectId@ of that object
**** @(RTLM20e5b)@ If the @value@ is of type @JsonArray@ or @JsonObject@, set @ObjectMessage.operation.mapOp.data.json@ to that value
**** @(RTLM20e5c)@ If the @value@ is of type @String@, set @ObjectMessage.operation.mapOp.data.string@ to that value
**** @(RTLM20e5d)@ If the @value@ is of type @Number@, set @ObjectMessage.operation.mapOp.data.number@ to that value
**** @(RTLM20e5e)@ If the @value@ is of type @Boolean@, set @ObjectMessage.operation.mapOp.data.boolean@ to that value
**** @(RTLM20e5f)@ If the @value@ is of type @Binary@, set @ObjectMessage.operation.mapOp.data.bytes@ to that value
** @(RTLM20f)@ Publishes the @ObjectMessage@ from "RTLM20e":#RTLM20e using "@RealtimeObjects#publish@":#RTO15, passing the @ObjectMessage@ as a single element in the array
* @(RTLM21)@ @LiveMap#remove@ function:
** @(RTLM21a)@ Expects the following arguments:
*** @(RTLM21a1)@ @key@ @String@ - the key to remove the value for
** @(RTLM21b)@ Requires the @OBJECT_PUBLISH@ channel mode to be granted per "RTO2":#RTO2
** @(RTLM21c)@ If the channel is in the @DETACHED@, @FAILED@ or @SUSPENDED@ state, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 90001
** @(RTLM21d)@ If "@echoMessages@":../features#TO3h client option is @false@, the library should throw an @ErrorInfo@ error with @statusCode@ 400 and @code@ 40000, indicating that @echoMessages@ must be enabled for this operation
** @(RTLM21e)@ Creates an @ObjectMessage@ for a @MAP_REMOVE@ action in the following way:
*** @(RTLM21e1)@ Validates the provided @key@ in a similar way as described in "RTO11f2":#RTO11f2
*** @(RTLM21e2)@ Set @ObjectMessage.operation.action@ to @ObjectOperationAction.MAP_REMOVE@
*** @(RTLM21e3)@ Set @ObjectMessage.operation.objectId@ to the Object ID of this @LiveMap@
*** @(RTLM21e4)@ Set @ObjectMessage.operation.mapOp.key@ to the provided @key@ value
** @(RTLM21f)@ Publishes the @ObjectMessage@ from "RTLM21e":#RTLM21e using "@RealtimeObjects#publish@":#RTO15, passing the @ObjectMessage@ as a single element in the array
* @(RTLM14)@ An @ObjectsMapEntry@ in the internal @data@ map can be checked for being tombstoned using the convenience method:
** @(RTLM14a)@ The method returns true if @ObjectsMapEntry.tombstone@ is true
** @(RTLM14c)@ The method returns true if @ObjectsMapEntry.data.objectId@ exists, there is an object in the local @ObjectsPool@ with that id, and that @LiveObject.isTombstone@ property is @true@
** @(RTLM14b)@ Otherwise, it returns false
* @(RTLM6)@ @LiveMap@ internal @data@ can be replaced with the provided @ObjectState@ in the following way:
** @(RTLM6a)@ Replace the private @siteTimeserials@ of the @LiveMap@ with the value from @ObjectState.siteTimeserials@
** @(RTLM6e)@ If @LiveMap.isTombstone@ is @true@, finish processing the @ObjectState@
*** @(RTLM6e1)@ Return a @LiveMapUpdate@ object with @LiveMapUpdate.noop@ set to @true@, indicating that no update was made to the object
** @(RTLM6f)@ If @ObjectState.tombstone@ is @true@, tombstone the current @LiveMap@ using "@LiveObject.tombstone@":#RTLO4e, passing in the outer @ObjectMessage@ for the @ObjectState@. Finish processing the @ObjectState@
*** @(RTLM6f1)@ Return a @LiveMapUpdate@ object with @LiveMapUpdate.update@ consisting of entries for the keys that were removed as a result of the object being tombstoned, each set to @removed@
** @(RTLM6b)@ Set the private flag @createOperationIsMerged@ to @false@
** @(RTLM6c)@ Set @data@ to @ObjectState.map.entries@, or to an empty map if it does not exist
*** @(RTLM6c1)@ For each @ObjectsMapEntry@ with @ObjectsMapEntry.tombstone@ equal to @true@, additionally set the @ObjectsMapEntry.tombstonedAt@ field as follows:
**** @(RTLM6c1a)@ Set it equal to @ObjectsMapEntry.serialTimestamp@ if it exists
**** @(RTLM6c1b)@ Otherwise, set it to the current time using the local clock
***** @(RTLM6c1b1)@ Log a debug or trace message indicating that @ObjectsMapEntry.serialTimestamp@ was not provided and the local clock is being used instead for the tombstone timestamp
** @(RTLM6d)@ If @ObjectState.createOp@ is present, merge the initial value into the @LiveMap@ as described in "RTLM17":#RTLM17, passing in the @ObjectState.createOp@ instance
*** @(RTLM6d1)@ This clause has been replaced by "RTLM17a":#RTLM17a
**** @(RTLM6d1a)@ This clause has been replaced by "RTLM17a1":#RTLM17a1
**** @(RTLM6d1b)@ This clause has been replaced by "RTLM17a2":#RTLM17a2
*** @(RTLM6d2)@ This clause has been replaced by "RTLM17b":#RTLM17b
** @(RTLM6g)@ Return a @LiveMapUpdate@ object that reflects the change in value caused by applying "RTLM6":#RTLM6. Construct the update using the procedure defined in "RTLM22":#RTLM22, passing in the @previous@ @data@ value that the @LiveMap@ had before applying "RTLM6":#RTLM6, and the @new@ @data@ value that the @LiveMap@ has after applying "RTLM6d":#RTLM6d
* @(RTLM15)@ An @ObjectOperation@ from @ObjectMessage.operation@ can be applied to a @LiveMap@ by performing the following actions in order:
** @(RTLM15a)@ A client library may choose to implement this logic as a convenience method named @applyOperation@, which accepts an @ObjectMessage@ instance with an existing @ObjectMessage.operation@ object, with @ObjectMessage.operation.objectId@ matching the Object ID of this @LiveMap@. This @ObjectMessage@ represents the operation to be applied to this @LiveMap@
** @(RTLM15b)@ If @ObjectMessage.operation@ cannot be applied based on the result of "@LiveObject.canApplyOperation@":#RTLO4a, log a debug or trace message indicating that the operation cannot be applied because its serial value is not newer than the object's, and discard the @ObjectMessage@ without taking any further action
** @(RTLM15c)@ Set the entry in the private @siteTimeserials@ map at the key @ObjectMessage.siteCode@ to equal @ObjectMessage.serial@
** @(RTLM15e)@ If @LiveMap.isTombstone@ is @true@, the operation cannot be applied to the object. Finish processing the @ObjectMessage@ without taking any further action. No data update event is emitted
** @(RTLM15d)@ The @ObjectMessage.operation.action@ field (see "@ObjectOperationAction@":../features#OOP2) determines the type of operation to apply:
*** @(RTLM15d1)@ If @ObjectMessage.operation.action@ is set to @MAP_CREATE@, apply the operation as described in "RTLM16":#RTLM16, passing in @ObjectMessage.operation@
**** @(RTLM15d1a)@ Emit the @LiveMapUpdate@ object returned as a result of applying the operation
*** @(RTLM15d2)@ If @ObjectMessage.operation.action@ is set to @MAP_SET@, apply the operation as described in "RTLM7":#RTLM7, passing in @ObjectMessage.operation.mapOp@ and @ObjectMessage.serial@
**** @(RTLM15d2a)@ Emit the @LiveMapUpdate@ object returned as a result of applying the operation
*** @(RTLM15d3)@ If @ObjectMessage.operation.action@ is set to @MAP_REMOVE@, apply the operation as described in "RTLM8":#RTLM8, passing in @ObjectMessage.operation.mapOp@, @ObjectMessage.serial@ and @ObjectMessage.serialTimestamp@
**** @(RTLM15d3a)@ Emit the @LiveMapUpdate@ object returned as a result of applying the operation
*** @(RTLM15d5)@ If @ObjectMessage.operation.action@ is set to @OBJECT_DELETE@, apply the operation as described in "RTLO5":#RTLO5, passing in @ObjectMessage@
**** @(RTLM15d5a)@ Emit a @LiveMapUpdate@ object with @LiveMapUpdate.update@ consisting of entries for the keys that were removed as a result of applying the @OBJECT_DELETE@ operation, each set to @removed@
*** @(RTLM15d4)@ Otherwise, log a warning that an object operation message with an unsupported action has been received, and discard the current @ObjectMessage@ without taking any further action. No data update event is emitted
* @(RTLM16)@ A @MAP_CREATE@ operation can be applied to a @LiveMap@ in the following way:
** @(RTLM16a)@ Expects the following arguments:
*** @(RTLM16a1)@ @ObjectOperation@
** @(RTLM16e)@ The return type is a @LiveMapUpdate@ object, which indicates the data update for this @LiveMap@
** @(RTLM16b)@ If the private flag @createOperationIsMerged@ is @true@, log a debug or trace message indicating that the operation will not be applied because a @MAP_CREATE@ operation has already been applied to this @LiveMap@. Discard the operation without taking any further action, and return a @LiveMapUpdate@ object with @LiveMapUpdate.noop@ set to @true@, indicating that no update was made to the object
** @(RTLM16c)@ If the private @semantics@ field does not match @ObjectOperation.map.semantics@, log a warning that the operation cannot be applied due to mismatched semantics. Discard the operation without taking any further action, and return a @LiveMapUpdate@ object with @LiveMapUpdate.noop@ set to @true@, indicating that no update was made to the object
** @(RTLM16d)@ Otherwise merge the initial value into the @LiveMap@ as described in "RTLM17":#RTLM17, passing in the @ObjectOperation@ instance
** @(RTLM16f)@ Return the @LiveMapUpdate@ object returned by "RTLM17":#RTLM17
* @(RTLM7)@ A @MAP_SET@ operation for a key can be applied to a @LiveMap@ in the following way:
** @(RTLM7d)@ Expects the following arguments:
*** @(RTLM7d1)@ @ObjectsMapOp@
*** @(RTLM7d2)@ @serial@ string - operation's serial value
** @(RTLM7e)@ The return type is a @LiveMapUpdate@ object, which indicates the data update for this @LiveMap@
** @(RTLM7a)@ If an @ObjectsMapEntry@ exists in the private @data@ for the specified key:
*** @(RTLM7a1)@ If the operation cannot be applied to the existing entry as per "RTLM9":#RTLM9, discard the operation without taking any action. Return a @LiveMapUpdate@ object with @LiveMapUpdate.noop@ set to @true@, indicating that no update was made to the object
*** @(RTLM7a2)@ Otherwise, apply the operation to the existing entry:
**** @(RTLM7a2a)@ Set @ObjectsMapEntry.data@ to the @ObjectData@ from the operation
**** @(RTLM7a2b)@ Set @ObjectsMapEntry.timeserial@ to the provided @serial@
**** @(RTLM7a2c)@ Set @ObjectsMapEntry.tombstone@ to @false@
**** @(RTLM7a2d)@ Set @ObjectsMapEntry.tombstonedAt@ to undefined/null
** @(RTLM7b)@ If an entry does not exist in the private @data@ for the specified key:
*** @(RTLM7b1)@ Create a new @ObjectsMapEntry@ in @data@ for the specified key, with @ObjectsMapEntry.data@ set to the provided @ObjectData@ and @ObjectsMapEntry.timeserial@ set to @serial@
*** @(RTLM7b2)@ Set @ObjectsMapEntry.tombstone@ for the new entry to @false@
*** @(RTLM7b3)@ Set @ObjectsMapEntry.tombstonedAt@ for the new entry to undefined/null
** @(RTLM7c)@ If the operation has a non-empty @ObjectData.objectId@ attribute:
*** @(RTLM7c1)@ Create a zero-value @LiveObject@ for this @ObjectData.objectId@ in the internal @ObjectsPool@ per "RTO6":#RTO6
** @(RTLM7f)@ Return a @LiveMapUpdate@ object with a @LiveMapUpdate.update@ map containing the key used in this operation set to @updated@
* @(RTLM8)@ A @MAP_REMOVE@ operation for a key can be applied to a @LiveMap@ in the following way:
** @(RTLM8c)@ Expects the following arguments:
*** @(RTLM8c1)@ @ObjectsMapOp@
*** @(RTLM8c2)@ @serial@ string - operation's serial value
*** @(RTLM8c3)@ @serialTimestamp@ Time - operation's serial timestamp value
** @(RTLM8d)@ The return type is a @LiveMapUpdate@ object, which indicates the data update for this @LiveMap@
** @(RTLM8a)@ If an @ObjectsMapEntry@ exists in the private @data@ for the specified key:
*** @(RTLM8a1)@ If the operation cannot be applied to the existing entry as per "RTLM9":#RTLM9, discard the operation without taking any action. Return a @LiveMapUpdate@ object with @LiveMapUpdate.noop@ set to @true@, indicating that no update was made to the object
*** @(RTLM8a2)@ Otherwise, apply the operation to the existing entry:
**** @(RTLM8a2a)@ Set @ObjectsMapEntry.data@ to undefined/null
**** @(RTLM8a2b)@ Set @ObjectsMapEntry.timeserial@ to the provided @serial@
**** @(RTLM8a2c)@ Set @ObjectsMapEntry.tombstone@ to @true@
**** @(RTLM8a2d)@ Set @ObjectsMapEntry.tombstonedAt@ to the value from "RTLM8f":#RTLM8f
** @(RTLM8b)@ If an entry does not exist in the private @data@ for the specified key:
*** @(RTLM8b1)@ Create a new @ObjectsMapEntry@ in @data@ for the specified key, with @ObjectsMapEntry.data@ set to undefined/null and @ObjectsMapEntry.timeserial@ set to the provided @serial@
*** @(RTLM8b2)@ Set @ObjectsMapEntry.tombstone@ for the new entry to @true@
*** @(RTLM8b3)@ Set @ObjectsMapEntry.tombstonedAt@ for the new entry to the value from "RTLM8f":#RTLM8f
** @(RTLM8f)@ The @tombstonedAt@ value for the map entry can be calculated in the following way:
*** @(RTLM8f1)@ It is equal to @serialTimestamp@ if it exists
*** @(RTLM8f2)@ Otherwise, it is equal to the current time using the local clock
**** @(RTLM8f2a)@ Log a debug or trace message that @serialTimestamp@ was not provided for the message and the local clock is used for the tombstone timestamp instead
** @(RTLM8e)@ Return a @LiveMapUpdate@ object with a @LiveMapUpdate.update@ map containing the key used in this operation set to @removed@
* @(RTLM9)@ Whether a map operation can be applied to a map entry is determined as follows:
** @(RTLM9a)@ For a @LiveMap@ with @semantics@ set to @ObjectsMapSemantics.LWW@ (Last-Write-Wins CRDT semantics), the operation must only be applied if its serial is strictly greater ("after") than the entry's serial when compared lexicographically
** @(RTLM9b)@ If both the entry serial and the operation serial are null or empty strings, they are treated as the "earliest possible" serials and considered "equal", so the operation must not be applied
** @(RTLM9c)@ If only the entry serial exists and is not an empty string, the missing operation serial is considered lower than the existing entry serial, so the operation must not be applied
** @(RTLM9d)@ If only the operation serial exists and is not an empty string, it is considered greater than the missing entry serial, so the operation can be applied
** @(RTLM9e)@ If both serials exist and are not empty strings, compare them lexicographically and allow operation to be applied only if the operation's serial is greater than the entry's serial
* @(RTLM17)@ The initial value from @ObjectOperation.map@ can be merged into this @LiveMap@ in the following way:
** @(RTLM17a)@ For each key-@ObjectsMapEntry@ pair in @ObjectOperation.map.entries@:
*** @(RTLM17a1)@ If @ObjectsMapEntry.tombstone@ is @false@ or omitted, apply the @MAP_SET@ operation to the current key as described in "RTLM7":#RTLM7, passing in @ObjectsMapEntry.data@ and the current key as @ObjectsMapOp@, and @ObjectsMapEntry.timeserial@ as @serial@. Store the returned @LiveMapUpdate@ object for use in "RTLM17c":#RTLM17c
*** @(RTLM17a2)@ If @ObjectsMapEntry.tombstone@ is @true@, apply the @MAP_REMOVE@ operation to the current key as described in "RTLM8":#RTLM8, passing in the current key as @ObjectsMapOp@, @ObjectsMapEntry.timeserial@ as @serial@, and @ObjectsMapEntry.serialTimestamp@ as @serialTimestamp@. Store the returned @LiveMapUpdate@ object for use in "RTLM17c":#RTLM17c
** @(RTLM17b)@ Set the private flag @createOperationIsMerged@ to @true@
** @(RTLM17c)@ Return a single @LiveMapUpdate@ object, where @LiveMapUpdate.update@ is a merged map containing all key-value pairs from the @LiveMapUpdate.update@ maps of the stored @LiveMapUpdate@ objects. Skip any stored @LiveMapUpdate@ objects marked as no-op
* @(RTLM19)@ The @LiveMap@ can be checked to determine whether it should release resources for its tombstoned @ObjectsMapEntry@ entries as follows:
** @(RTLM19a)@ For each @ObjectsMapEntry@ in the internal @data@:
*** @(RTLM19a1)@ If @ObjectsMapEntry.tombstone@ is @true@, and the difference between the current time and @ObjectsMapEntry.tombstonedAt@ is greater than or equal to the "grace period":#RTO10b, remove the entry from the internal @data@ map and release resources for the corresponding @ObjectsMapEntry@ entity to allow it to be garbage collected
* @(RTLM22)@ A @LiveMapUpdate@ for the difference between two @LiveMap@ @data@ values (referred to as "previous" and "new" values) can be created using the convenience method:
** @(RTLM22a)@ Expects the following arguments:
*** @(RTLM22a1)@ @previous@ @Dict<String, ObjectsMapEntry>@
*** @(RTLM22a2)@ @new@ @Dict<String, ObjectsMapEntry>@
** @(RTLM22b)@ The return type is a @LiveMapUpdate@ object, which indicates the data update for this @LiveMap@
** @(RTLM22c)@ TODO

h2(#idl). Interface Definition

Describes types for RealtimeObjects.
Types and their properties/methods are public and exposed to users by default. An @internal@ label may be used to indicate that a type or its property/method must not be exposed to users and is intended for internal SDK use only.

<pre>
class RealtimeObjects: // RTO*
  getRoot() => io LiveMap // RTO1
  createMap(Dict<String, Boolean | Binary | Number | String | JsonArray | JsonObject | LiveCounter | LiveMap> entries?) => io LiveMap // RTO11
  createCounter(Number count?) => io LiveCounter // RTO12
  publish(ObjectMessage[]) => io // RTO15, internal

class LiveObject: // RTLO*
  objectId: String // RTLO3a, internal
  siteTimeserials: Dict<String, String> // RTLO3b, internal
  createOperationIsMerged: Boolean // RTLO3c, internal
  isTombstone: Boolean // RTLO3d, internal
  tombstonedAt: Time? // RTLO3e, internal
  canApplyOperation(ObjectMessage) -> Boolean // RTLO4a, internal
  tombstone(ObjectMessage) // RTLO4e, internal
  subscribe((LiveObjectUpdate) ->) -> LiveObjectSubscription // RTLO4b
  unsubscribe((LiveObjectUpdate) ->) // RTLO4c
  unsubscribeAll() // RTLO4d

interface LiveObjectSubscription: // RTLO4b5
  unsubscribe() // RTLO4b5a

interface LiveObjectUpdate: // RTLO4b4
  update: Object // RTLO4b4a
  noop: Boolean // RTLO4b4b, internal

class LiveCounter extends LiveObject: // RTLC*, RTLC1
  value() -> Number // RTLC5
  increment(Number amount) => io // RTLC12
  decrement(Number amount) => io // RTLC13

interface LiveCounterUpdate extends LiveObjectUpdate: // RTLC11, RTLC11a
  update: { amount: Number } // RTLC11b, RTLC11b1

class LiveMap extends LiveObject: // RTLM*, RTLM1
  get(key: String) -> (Boolean | Binary | Number | String | JsonArray | JsonObject | LiveCounter | LiveMap)? // RTLM5
  size() -> Number // RTLM10
  entries() -> [String, (Boolean | Binary | Number | String | JsonArray | JsonObject | LiveCounter | LiveMap)?][] // RTLM11
  keys() -> String[] // RTLM12
  values() -> (Boolean | Binary | Number | String | JsonArray | JsonObject | LiveCounter | LiveMap)?[] // RTLM13
  set(String key, (Boolean | Binary | Number | String | JsonArray | JsonObject | LiveCounter | LiveMap) value) => io // RTLM20
  remove(String key) => io // RTLM21

interface LiveMapUpdate extends LiveObjectUpdate: // RTLM18, RTLM18a
  update: Dict<String, 'updated' | 'removed'> // RTLM18b
</pre>
